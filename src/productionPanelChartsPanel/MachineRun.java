package productionPanelChartsPanel;

import com.jidesoft.chart.Chart;
import com.jidesoft.chart.LabelPlacement;
import com.jidesoft.chart.LineMarker;
import com.jidesoft.chart.Orientation;
import com.jidesoft.chart.RectangularRegionMarker;
import com.jidesoft.chart.annotation.AutoPositionedLabel;
import com.jidesoft.chart.axis.Axis;
import com.jidesoft.chart.axis.CategoryAxis;
import com.jidesoft.chart.event.ChartSelectionEvent;
import com.jidesoft.chart.event.PointSelectionEvent;
import com.jidesoft.chart.event.RectangleSelectionEvent;
import com.jidesoft.chart.event.RubberBandZoomer;
import com.jidesoft.chart.event.ZoomFrame;
import com.jidesoft.chart.event.ZoomListener;
import com.jidesoft.chart.model.ChartModel;
import com.jidesoft.chart.model.ChartPoint;
import com.jidesoft.chart.model.DefaultChartModel;
import com.jidesoft.chart.model.Highlight;
import com.jidesoft.chart.style.ChartStyle;
import com.jidesoft.range.Category;
import com.jidesoft.range.CategoryRange;
import com.jidesoft.range.NumericRange;
import com.jidesoft.range.Range;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GradientPaint;
import java.awt.HeadlessException;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Point2D;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Stack;
import java.util.logging.Logger;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.border.EmptyBorder;
import productionPanel.ProductionPane;
import smartfactoryV2.ConnectDB;

/**
 *
 * @author Victor Kadiata
 */
public class MachineRun extends javax.swing.JPanel {

    public MachineRun(int ChannelID, String query) throws SQLException {
        this._IDChannel = ChannelID;
        this._query = query;
        this.removeAll();
        this.repaint();
        Chart chartPanel = new StepChart(_IDChannel, _query).chart;
        initComponents();
//        setLayout(new BorderLayout());
        if (chartPanel != null) {
            this.add(chartPanel, BorderLayout.CENTER);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this
     * code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    class StepChart extends Chart {

        public StepChart(int IDChannel, String query) throws SQLException {
            chart = new Chart("Step Chart");
            chart.removeAll();
            String machineName = ProductionPane.cmbMachineTitle.getSelectedItem().toString();
            ProductionPane.getComponentDates();//get the dates from the production class      
            try (PreparedStatement ps = ConnectDB.con.prepareStatement(query)) {
                int i = 1;
                ps.setString(i++, machineName);
                ps.setInt(i++, IDChannel);
                ps.setString(i++, ConnectDB.SDATE_FORMAT_HOUR.format(ProductionPane.dt_startP));
                ps.setString(i++, ConnectDB.SDATE_FORMAT_HOUR.format(ProductionPane.dt_endP));
                ConnectDB.res = ps.executeQuery();
//                System.out.println(ps.toString());
                alTime.clear();
                alValues.clear();
                while (ConnectDB.res.next()) {
                    loopQueryFound = true;
                    alTime.add(ConnectDB.res.getString(1)); //Time
                    alValues.add(ConnectDB.res.getInt(2)); //Values
                }
            } 
            if (loopQueryFound) {
                String categoryString = "Machine";
                xEnd = (double) alValues.size() + 1;
                chart.setPreferredSize(new Dimension(600, 300));
                chart.setTitle(new AutoPositionedLabel("Step Charts (ON/OFF) for \"" + machineName + "\"",
                        Color.BLACK, ConnectDB.TITLEFONT));
                chart.setAnimateOnShow(true);
                chart.setAntiAliasing(false);

                double[] vTransition = new double[alValues.size()];
                int i = 0;
                for (double v1 : alValues) {
                    vTransition[i++] = i + 1;
                }
                boolean firstValueState = false;
                if (alValues.get(0) == 1) {
                    firstValueState = true;
                }
                BinaryTrace bt = new BinaryTrace(firstValueState, vTransition);
                Category<BinaryTrace> cat = new Category<>(categoryString, bt);
                yRange.add(cat);
                CategoryAxis<BinaryTrace> yCatAxis = new CategoryAxis<>(yRange);
                yCatAxis.setTicksVisible(true);
//                yAxis.setTickLength(0);
                // Paint some 'tram lines' for each of the categories
                for (Category<BinaryTrace> category : yRange.getCategoryValues()) {
                    double pos = category.position();
                    RectangularRegionMarker marker = new RectangularRegionMarker(chart, xStart, xEnd,
                            pos - binaryOffset, pos + binaryOffset, new Color(200, 200, 255, 75));
                    marker.setOutlineColor(new Color(140, 140, 140, 75));
                    chart.addDrawable(marker);
                }
                for (int j = 0; j < distances.length; j++) {
                    LineMarker marker = new LineMarker(chart, Orientation.horizontal, distances[j], Color.GRAY);
                    marker.setLabel(names[j]);
                    marker.setLabelPlacement(LabelPlacement.NORTH_WEST);
                    chart.addDrawable(marker);
                }

                Range<?> xRange = new NumericRange(xStart, xEnd);
                final Axis xAxis = new Axis(xRange, "Time");
                final Axis yAxis = new Axis(yCatAxis.getRange());
                xAxis.setTicksVisible(true);
                xAxis.setMinorTickColor(Color.RED);

                chart.setXAxis(xAxis);
                chart.setYAxis(yCatAxis);
                chart.setHorizontalGridLinesVisible(false);
                chart.setVerticalGridLinesVisible(false);
                chart.setGridColor(new Color(150, 150, 150));
//                chart.setGridColor(new Color(220, 220, 220));
                chart.setBorder(new EmptyBorder(5, 5, 10, 15));
                for (Category<BinaryTrace> c : yRange.getCategoryValues()) {
                    BinaryTrace b = c.getValue();
                    ChartModel model = b.getModel(c);
                    ChartStyle style = new ChartStyle(Color.RED).withLines();
                    style.setLineWidth(2);
                    chart.addModel(model, style);
                }
                ChartStyle continuityStyle = continuousStyle;
//                chart.addMouseZoomer().addMousePanner();
                chart.setHighlightStyle(discontinuity, continuityStyle);
                chart.setPanelBackground(new Color(153, 153, 153));
                chart.setChartBackground(new GradientPaint(0f, 0f, Color.lightGray.brighter(), 300f, 300f,
                        Color.lightGray));
                chart.setLabelColor(Color.BLACK);

                RubberBandZoomer rubberBand = new RubberBandZoomer(chart);
//            rubberBand.setOutlineColor(null);
//            rubberBand.setOutlineStroke(new BasicStroke(1f));
                rubberBand.setFill(new Color(128, 128, 128, 50));
                rubberBand.setKeepWidthHeightRatio(true);
                chart.addDrawable(rubberBand);
                chart.addMouseListener(rubberBand);
                chart.addMouseMotionListener(rubberBand);

                rubberBand.addZoomListener(new ZoomListener() {
                    @Override
                    public void zoomChanged(ChartSelectionEvent event) {
                        if (event instanceof RectangleSelectionEvent) {
                            Range<?> currentXRange = chart.getXAxis().getOutputRange();
                            Range<?> currentYRange = chart.getYAxis().getOutputRange();
                            ZoomFrame frame = new ZoomFrame(currentXRange, currentYRange);
                            zoomStack.push(frame);
                            Rectangle selection = (Rectangle) event.getLocation();
                            Point topLeft = selection.getLocation();
                            Point bottomRight = new Point(topLeft.x + selection.width, topLeft.y + selection.height);
                            assert bottomRight.x >= topLeft.x;
                            Point2D rp1 = chart.calculateUserPoint(topLeft);
                            Point2D rp2 = chart.calculateUserPoint(bottomRight);
                            if (rp1 != null && rp2 != null) {
                                // Catch the problem case when division has led to NaN
                                if (Double.isNaN(rp1.getX()) || Double.isNaN(rp2.getX())
                                        || Double.isNaN(rp1.getY()) || Double.isNaN(rp2.getY())) {
                                    logger.warning("Cannot zoom as zoomed position is out of range");
                                    return;
                                }
                                assert rp2.getX() >= rp1.getX() : rp2.getX() + " must be greater than or equal to " + rp1.getX();
                                Range<?> xRange = new NumericRange(rp1.getX(), rp2.getX());
                                assert rp1.getY() >= rp2.getY() : rp1.getY() + " must be greater than or equal to " + rp2.getY();
                                Range<?> yRange = new NumericRange(rp2.getY(), rp1.getY());
                                xAxis.setRange(xRange);
                                yAxis.setRange(yRange);
                            }
                        } else if (event instanceof PointSelectionEvent) {
                            if (zoomStack.size() > 0) {
                                ZoomFrame frame = zoomStack.pop();
                                Range<?> xRange = frame.getXRange();
                                Range<?> yRange = frame.getYRange();
                                xAxis.setRange(xRange);
                                yAxis.setRange(yRange);
                            }
                        }
                    }
                });
            } else {
                chart = null;
                JOptionPane.showMessageDialog(null, "No data retrieved. Please check "
                        + "the dates and time provided", "Chart", JOptionPane.WARNING_MESSAGE);
            }
        }
        public Chart chart;
    }

    class BinaryTrace {

        private final double[] transitions;
        private final boolean initialState;

        public BinaryTrace(boolean initialState, double... transitions) {
            this.initialState = initialState;
            this.transitions = transitions;
        }

        public ChartModel getModel(Category<?> category) {
            DefaultChartModel model = new DefaultChartModel();
            boolean state = initialState;
            model.addPoint(xStart, getY(category, state));
            for (int i = 0; i < transitions.length; i++) {
                double transition = transitions[i];
                ChartPoint p1 = new ChartPoint(transition, getY(category, state));
                p1.setHighlight(discontinuity);
                model.addPoint(p1);
                state = alValues.get(i) == 1;
                ChartPoint p2 = new ChartPoint(transition, getY(category, state));
                model.addPoint(p2);
            }
            model.addPoint(xEnd, getY(category, state));
            return model;
        }

        private double getY(Category<?> category, boolean state) {
            return state ? category.position() + binaryOffset : category.position() - binaryOffset;
        }
    }

    public static void main(String[] agrs) {
        try {
            final JFrame frame = new JFrame("Machine Run");
            String query = "SELECT dl0.LogTime AS 'Time', dl0.LogData AS ? "
                    + "FROM datalog dl0 "
                    + "WHERE dl0.ConfigNo =? "
                    + "AND dl0.LogTime >=? AND dl0.LogTime <=? "
                    + "ORDER BY 'Time' ASC";
            frame.setSize(800, 500);
            frame.setContentPane(new MachineRun(10, query));
            frame.addWindowListener(new WindowAdapter() {

                @Override
                public void windowClosing(WindowEvent e) {
                    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                }
            });
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        } catch (HeadlessException | SQLException e) {
//            e.printStackTrace();
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    // Defines the width of the gap between the true and false values for a bit trace
    // This value must be between 0 and 0.5
    private boolean loopQueryFound = false;
    private final int _IDChannel;
    private String _query = "";
    private static final double binaryOffset = 0.30;
    private final ChartStyle continuousStyle = new ChartStyle(Color.black).withLines();
    private final Highlight discontinuity = new Highlight("discontinuity");
    private final double xStart = 0.0;
    private double xEnd = 8;
    private final CategoryRange<BinaryTrace> yRange = new CategoryRange<>();
    public static ArrayList<String> alTime = new ArrayList<>();
//    private static MouseDragPanner panner;
    public static ArrayList<Integer> alValues = new ArrayList<>();
    private final double[] distances = {1.3, 0.7};
    private final String[] names = {"ON", "OFF"};
    private final Stack<ZoomFrame> zoomStack = new Stack<>();
    private static final Logger logger = Logger.getLogger(MachineRun.class.getName());
}
